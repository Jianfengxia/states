{#-
 Author: Bruno Clermont patate@fastmail.cn
 Maintainer: Bruno Clermont patate@fastmail.cn
 -#}
# {{ pillar['message_do_not_modify'] }}
{%- set mine = salt['mine.get']('*', 'monitoring.data') %}

define host {
    name salt-host
    contact_groups admins
    notification_interval 0
    first_notification_delay 0
    notification_options d,u,r
    notification_period 24x7
    notifications_enabled 1
    active_checks_enabled 1
    check_period 24x7
    check_interval 2
    retry_interval 1
    max_check_attempts 2
    check_command check_ping
    event_handler_enabled 0
    flap_detection_enabled 1
    process_perf_data 1
    retain_status_information 1
    retain_nonstatus_information 1
    business_impact 5
    register 0
}

{%- for host in mine -%}
{%- if mine[host]['monitor'] %}
define host {
    use salt-host
    host_name {{ host }}
    address {{ mine[host]['ip_addrs']['private'] }}
    alias {{ host }}
    hostgroups {% for role in mine[host]['roles'] %}{{ role }}{% if not loop.last %},{% endif %}{% endfor %}
    poller_tag all
}
{% endif -%}
{%- endfor -%}

define contact {
    name salt-contact
    can_submit_commands 1
    is_admin 1
    host_notification_period 24x7
    host_notification_options d,u,r,f,s
    host_notification_commands notify-host-by-email
    host_notifications_enabled 1
    service_notification_period 24x7
    service_notification_options c,w,r,u
    service_notification_commands notify-service-by-email
    service_notifications_enabled 1
    register 0
}

{#-
 This file contains the checks for the low-level infrastructure components
 supported by salt.
#}

{%- for user in pillar['shinken']['users'] %}
define contact {
    contact_name {{ user }}
    email {{ pillar['shinken']['users'][user]['email'] }}
    password {{ pillar['shinken']['users'][user]['password'] }}
    use salt-contact
}
{% endfor -%}

define contactgroup {
    contactgroup_name admins
    alias admins
    members {% for user in pillar['shinken']['users'] %}{{ user }}{% if not loop.last %},{% endif %}{% endfor %}
    # host notifications can be sent anytime
    host_notification_period 24x7
    # send notifications for all host states, flapping events (f), and scheduled
    # downtime events (s)
    host_notification_options d,u,r,f,s
    # send host notifications via email
    host_notification_commands notify-host-by-email
    host_notifications_enabled 1

    # service notifications can be sent anytime
    service_notification_period 24x7
    service_notification_options c,w,r,u
    # send service notifications via email
    service_notification_commands notify-service-by-email
    service_notifications_enabled 1
}

define command {
    command_name notify-host-by-email
    command_line /usr/bin/printf "%b" "Shinken Notification\n\nType:$NOTIFICATIONTYPE$\nHost: $HOSTALIAS$\nState: $HOSTSTATE$\nAddress: $HOSTADDRESS$\nInfo: $HOSTOUTPUT$\nWhen: $LONGDATETIME$\n\nLast Up: $LASTHOSTUP$\nLast Down: $LASTHOSTDOWN$\nLast Unreachable: $LASTHOSTUNREACHABLE$\n\nURL: http{% if pillar['shinken']['ssl']|default(False) %}s{% endif %}://{{ pillar['shinken']['web']['hostnames'][0] }}/host/$HOSTNAME$ " | /usr/bin/bsd-mailx -s "Host $HOSTSTATE$ alert for $HOSTNAME$!" $CONTACTEMAIL$

# send email for a service
define command {
    command_name notify-service-by-email
    command_line /usr/bin/printf "%b" "Shinken Notification\n\nNotification Type: $NOTIFICATIONTYPE$\n\nService: $SERVICEDESC$\nHost: $HOSTALIAS$\nAddress: $HOSTADDRESS$\nState: $SERVICESTATE$\nWhen: $LONGDATETIME$\n\nAdditional Info : $SERVICEOUTPUT$\n\nLast OK: $LASTSERVICEOK$\nLast Warning: $LASTSERVICEWARNING$\nLast Unknown: $LASTSERVICEUNKNOWN$\nLast Critical: $LASTSERVICECRITICAL$\n\nServices OK: $TOTALSERVICESOK$\nServices Warning/Unhandled: $TOTALSERVICESWARNING$/$TOTALSERVICESWARNINGUNHANDLED$\nServices Critical/Unhandled: $TOTALSERVICESCRITICAL$/$TOTALSERVICESCRITICALUNHANDLED$\nServices Unknown/Unhandled: $TOTALSERVICESUNKNOWN$/$TOTALSERVICESUNKNOWNUNHANDLED$\nTotal Services Problems/Unhandlded: $TOTALSERVICEPROBLEMS$/$TOTALSERVICEPROBLEMSUNHANDLED$\n\nURL: http{% if pillar['shinken']['ssl']|default(False) %}s{% endif %}://{{ pillar['shinken']['web']['hostnames'][0] }}/host/$HOSTNAME$ "| /usr/bin/bsd-mailx -s "** $NOTIFICATIONTYPE$ alert - $HOSTALIAS$/$SERVICEDESC$ is $SERVICESTATE$ ** " $CONTACTEMAIL$
}

define command {
    command_name check_nrpe
    command_line /usr/lib/nagios/plugins/check_nrpe -H $HOSTADDRESS$ -t 9 -u -c $ARG1$
}

define command {
   command_name check_ping
   command_line /usr/lib/nagios/plugins/check_ping -H $HOSTADDRESS$ -w 3000,100% -c 5000,100% -p 1
}

define command {
    command_name check_tcp
    command_line /usr/lib/nagios/plugins/check_tcp -H $HOSTADDRESS$ -p $ARG1$
}

define timeperiod {
    timeperiod_name 24x7
    alias 24_Hours_A_Day,_7_Days_A_Week
{%- for day in ('sun', 'mon', 'tues', 'wednes', 'thurs', 'fri', 'satur') %}
    {{ day }}day 00:00-24:00
{% endfor -%}
}

define service {
    name salt-service
    register 0

    # Active service checks are enabled
    active_checks_enabled 1
    # Passive service checks are enabled/accepted
    passive_checks_enabled 1
    # Active service checks should be parallelized (disabling this can lead
    # to major performance problems)
    parallelize_check 1
    # We should obsess over this service (if necessary)
    obsess_over_service 1
    # Default is to NOT check service 'freshness'
    check_freshness 1
    freshness_threshold 3600
    # Service notifications are enabled
    notifications_enabled 1
    event_handler_enabled 0
    # Service event handler is enabled
{#-    event_handler super_event_kill_everyone!DIE#}
    # Flap detection is enabled
    flap_detection_enabled 1
    # Failure prediction is enabled
    failure_prediction_enabled 1
    # Process performance data
    process_perf_data 1
    # Retain status information across program restarts
    retain_status_information 1
    # Retain non-status information across program restarts
    retain_nonstatus_information 1
    # The service is not volatile
    is_volatile 0
    # The service can be checked at any time of the day
    check_period 24x7
    # Re-check the service up to 3 times in order to determine its final (hard)
    # state
    max_check_attempts 2
    check_interval 5
    # Re-check the service every three minutes until a hard state can be
    # determined
    retry_interval 3
    contact_groups admins
    # Send notifications about warning, unknown, critical, and recovery events
    notification_options w,u,c,r
    # Re-notify about service problems every hour
    notification_interval 0
    notification_period 24x7
    _httpstink NO
}

{%- for role in pillar['global_roles'] %}
define hostgroup {
    hostgroup_name {{ role }}
    alias {{ role|capitalize }} Role
{#-
    members hosts
    hostgroup_members hostgroups
    notes note_string
    notes_url url
    action_url url
    realm realm
#}
}

define servicegroup {
    servicegroup_name {{ role }}
    alias {{ role|capitalize }} Role
}
{% endfor -%}

{%- set reserved_keys = ('check', 'description') -%}
{%- for state in pillar['monitoring']['states'] -%}
    {%- set state_checks = salt['monitoring.discover_checks'](state) -%}
    {%- if not state_checks %}
# ERROR: state {{ state }} don't have monitor.jinja2 file
    {%- else -%}
        {%- for name in state_checks %}
define service {
    hostgroup_name {% for role in pillar['monitoring']['states'][state] %}{{ role }}{% if not loop.last %},{% endif %}{% endfor %}
    servicegroups {% for role in pillar['monitoring']['states'][state] %}{{ role }}{% if not loop.last %},{% endif %}{% endfor %}
    use salt-service
    service_description {{ name }}
    display_name Amavis {{ state_checks[name]['description'] }}
    check_command {{ state_checks[name]['check']|default('check_nrpe!' + name) }}
            {%- for key_name in state_checks[name] %}
                {%- if key_name not in reserved_keys %}
    {{ key_name }} {{ state_checks[name][key_name] }}
                {%- endif %}
            {%- endfor %}
}
        {%- endfor %}
    {%- endif -%}
{%- endfor -%}
