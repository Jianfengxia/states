{#-
Copyright (c) 2013, Bruno Clermont
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Author: Bruno Clermont <bruno@robotinfra.com>
Maintainer: Viet Hung Nguyen <hvn@robotinfra.com>
-#}
# {{ salt['pillar.get']('message_do_not_modify') }}

{#-
 General Configuration
 Set your local timezone (Django's default is America/Chicago)
 If your graphs appear to be offset by a couple hours then this probably
 needs to be explicitly set to your local timezone.
#}
TIME_ZONE = '{{ salt['pillar.get']('timezone', 'UTC') }}'

{#- Override this to provide documentation specific to your Graphite deployment #}
DOCUMENTATION_URL = "http://graphite.readthedocs.org/"

{#- Logging #}
LOG_RENDERING_PERFORMANCE = {{ salt['pillar.get']('graphite:debug', False) }}
LOG_CACHE_PERFORMANCE = {{ salt['pillar.get']('graphite:debug', False) }}
LOG_METRIC_ACCESS = {{ salt['pillar.get']('graphite:debug', False) }}

{#- Enable full debug page display on exceptions (Internal Server Error pages)
#DEBUG = True

 If using RRD files and rrdcached, set to the address or socket of the daemon
 FLUSHRRDCACHED = 'unix:/var/run/rrdcached.sock'

 This lists the memcached servers that will be used by this webapp.
 If you have a cluster of webapps you should ensure all of them
 have the *exact* same value for this setting. That will maximize cache
 efficiency. Setting MEMCACHE_HOSTS to be empty will turn off use of
 memcached entirely.

 You should not use the loopback address (127.0.0.1) here if using clustering
 as every webapp in the cluster should use the exact same values to prevent
 unneeded cache misses. Set to [] to disable caching of images and fetched data
#}
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
        'LOCATION': 'unix:/tmp/memcached.sock',
    }
}
{#- Cache images and data for 1 minute #}
DEFAULT_CACHE_DURATION = 60


{#-
    Filesystem Paths
 Change only GRAPHITE_ROOT if your install is merely shifted from /opt/graphite
 to somewhere else
#}
GRAPHITE_ROOT = '/usr/local/graphite'

{#-
 Most installs done outside of a separate tree such as /opt/graphite will only
 need to change these three settings. Note that the default settings for each
 of these is relative to GRAPHITE_ROOT
#}
CONF_DIR = '/etc/graphite/'
STORAGE_DIR = '/var/lib/graphite'
CONTENT_DIR = '/usr/local/graphite/webapp/content'

{#-
 To further or fully customize the paths, modify the following. Note that the
 default settings for each of these are relative to CONF_DIR and STORAGE_DIR

 Webapp config files
DASHBOARD_CONF = '/opt/graphite/conf/dashboard.conf'
#}
GRAPHTEMPLATES_CONF = CONF_DIR + '/graphTemplates.conf'

CSS_DIR = GRAPHITE_ROOT + '/webapp/content/css/'

{#-
 Data directories
 NOTE: If any directory is unreadable in DATA_DIRS it will break metric browsing
WHISPER_DIR = '/opt/graphite/storage/whisper'
RRD_DIR = '/opt/graphite/storage/rrd'
DATA_DIRS = ['/var/lib/graphite/whisper']
#}
DATA_DIRS = [
{%- set instances_count = salt['pillar.get']('carbon:cache_daemons') %}
{%- for instance in range(instances_count) -%}
"/var/lib/graphite/whisper/{{ instance }}"{% if not loop.last %}, {% endif %}
{%- endfor -%}]
LOG_DIR = '/var/log/graphite/graphite'
INDEX_FILE = STORAGE_DIR + '/index'

{%- if salt['pillar.get']('graphite:smtp', False) %}
    {%- set smtp = salt['pillar.get']('graphite:smtp', False) %}
{%- else %}
    {%- set smtp = salt['pillar.get']('smtp') %}
{%- endif %}
EMAIL_HOST = '{{ smtp['server'] }}'
EMAIL_HOST_PASSWORD = '{{ smtp['password']|default('') }}'
EMAIL_HOST_USER = '{{ smtp['user']|default('') }}'
EMAIL_PORT = {{ smtp['port'] }}
DEFAULT_FROM_EMAIL = '{{ smtp['from'] }}'
{%- set encryption = smtp['encryption']|default('plain') -%}
{%- if encryption in ('ssl', 'starttls') %}
EMAIL_USE_TLS = True
    {%- if encryption == 'ssl' %}
EMAIL_BACKEND = 'django_smtp_ssl.SSLEmailBackend'
    {%- endif -%}
{%- else %}
EMAIL_USE_TLS = False
{%- endif %}

{#-
 Authentication Configuration
 LDAP / ActiveDirectory authentication setup
USE_LDAP_AUTH = True
LDAP_SERVER = "ldap.mycompany.com"
LDAP_PORT = 389
OR
LDAP_URI = "ldaps://ldap.mycompany.com:636"
LDAP_SEARCH_BASE = "OU=users,DC=mycompany,DC=com"
LDAP_BASE_USER = "CN=some_readonly_account,DC=mycompany,DC=com"
LDAP_BASE_PASS = "readonly_account_password"
LDAP_USER_QUERY = "(username=%s)"  #For Active Directory use "(sAMAccountName=%s)"

 If you want to further customize the ldap connection options you should
 directly use ldap.set_option to set the ldap module's global options.
 For example:

import ldap
ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_ALLOW)
ldap.set_option(ldap.OPT_X_TLS_CACERTDIR, "/etc/ssl/ca")
ldap.set_option(ldap.OPT_X_TLS_CERTFILE, "/etc/ssl/mycert.pem")
ldap.set_option(ldap.OPT_X_TLS_KEYFILE, "/etc/ssl/mykey.pem")
 See http://www.python-ldap.org/ for further details on these options.

 REMOTE_USER authentication. See: https://docs.djangoproject.com/en/dev/howto/auth-remote-user/
USE_REMOTE_USER_AUTHENTICATION = True

 Override the URL for the login link (e.g. for django_openid_auth)
LOGIN_URL = '/account/login'

 Database Configuration
 By default sqlite is used. If you cluster multiple webapps you will need
 to setup an external database (such as MySQL) and configure all of the webapp
 instances to use the same database. Note that this database is only used to store
 Django models such as saved graphs, dashboards, user preferences, etc.
 Metric data is not stored here.

 DO NOT FORGET TO RUN 'manage.py syncdb' AFTER SETTING UP A NEW DATABASE

 The following built-in database engines are available:
  django.db.backends.postgresql          # Removed in Django 1.4
  django.db.backends.postgresql_psycopg2
  django.db.backends.mysql
  django.db.backends.sqlite3
  django.db.backends.oracle

 The default is 'django.db.backends.sqlite3' with file 'graphite.db'
 located in STORAGE_DIR

 Users with Django 1.2 or greater should use the new dictionary
 specification as the old database specification style is removed in 1.4
#}

DATABASES = {
    'default': {
        'NAME': '{{ salt['pillar.get']('graphite:db:name', 'graphite') }}',
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'USER': '{{ salt['pillar.get']('graphite:db:username', 'graphite') }}',
        'PASSWORD': '{{ salt['password.pillar']('graphite:db:password', 10) }}',
        'HOST': '{{ salt['pillar.get']('graphite:db:host', '127.0.0.1') }}',
        'PORT': ''
    }
}

LOGGING = {
    'version': 1,
    'disable_existing_loggers': True,
    'formatters': {
        'message_only': {
            'format': '[graphite] %(message)s'
        },
        'syslog': {
            'format': '%(asctime)-15s graphite[%(process)d] %(levelname)s %(name)s %(module)s.%(funcName)s:%(lineno)d %(message)s',
            'datefmt': '%b %d %H:%M:%S'
        }
    },
    'handlers': {
{% if salt['pillar.get']('graylog2_address', False) %}
        'gelf': {
            'level': 'NOTSET',
            'class': 'graypy.handler.GELFHandler',
            'host': '{{ salt['pillar.get']('graylog2_address', False) }}',
            'formatter': 'message_only'
        },
{% endif %}
        'syslog': {
            'level': 'NOTSET',
            'formatter': 'syslog',
            'class': 'logging.handlers.SysLogHandler',
            'address': '/dev/log',
            'facility': '{% if salt['pillar.get']('graylog2_address', False) %}local7{% else %}daemon{% endif %}'
        },
        'sentry': {
            'level': 'ERROR',
            'class': 'raven.contrib.django.handlers.SentryHandler'
        }
    },
    'loggers': {
        'django': {
            'handlers': ['sentry', 'syslog'{% if salt['pillar.get']('graylog2_address', False) %}, 'gelf'{% endif %}],
            'propagate': True,
            'level':'DEBUG'
        },
        'raven': {
            'handlers': ['sentry', 'syslog'{% if salt['pillar.get']('graylog2_address', False) %}, 'gelf'{% endif %}],
            'level': 'WARN',
            'propagate': False
        },
        'sentry.errors': {
            'handlers': ['syslog'{% if salt['pillar.get']('graylog2_address', False) %}, 'gelf'{% endif %}],
            'level': 'DEBUG',
            'propagate': False
        },
{% if not salt['pillar.get']('graphite:debug', False) %}
{% for logger in ('cache', 'rendering', 'metric_access') %}
        '{{ logger }}': {
            'handlers': ['sentry', 'syslog'{% if salt['pillar.get']('graylog2_address', False) %}, 'gelf'{% endif %}],
            'level': 'ERROR',
            'propagate': False
        },
{% endfor %}
{% endif %}
     },
    'root': {
        'handlers': ['sentry', 'syslog'{% if salt['pillar.get']('graylog2_address', False) %}, 'gelf'{% endif %}],
        'propagate': True,
        'level': 'NOTSET'
    }
}

RAVEN_CONFIG = {
    'dsn': 'requests+{{ salt['pillar.get']('graphite:sentry', False)|default(salt['pillar.get']('sentry_dsn', False), boolean=True) }}',
}

{#-
 Cluster Configuration #
 (To avoid excessive DNS lookups you want to stick to using IP addresses only in this entire section)

 This should list the IP address (and optionally port) of the webapp on each
 remote server in the cluster. These servers must each have local access to
 metric data. Note that the first server to return a match for a query will be
 used.
 ["10.0.2.2:80", "10.0.2.3:80"]
#}

{%- set nodes = salt['pillar.get']('graphite:nodes', []) %}
CLUSTER_SERVERS = [{% for node in nodes %}"{{ node }}"{% if not loop.last %}, {% endif %}{% endfor %}]

{#-
 These are timeout values (in seconds) for requests to remote webapps
 Timeout to fetch series data
#}
REMOTE_STORE_FETCH_TIMEOUT = 6
{#- Timeout for metric find requests #}
REMOTE_STORE_FIND_TIMEOUT = 2.5
{#- Time before retrying a failed remote webapp #}
REMOTE_STORE_RETRY_DELAY = 60
{#- Time to cache remote metric find results #}
REMOTE_FIND_CACHE_DURATION = 300

{#-
 Remote rendering settings
 Set to True to enable rendering of Graphs on a remote webapp
#}
REMOTE_RENDERING = False
{#-
 List of IP (and optionally port) of the webapp on each remote server that
 will be used for rendering. Note that each rendering host should have local
 access to metric data or should have CLUSTER_SERVERS configured
RENDERING_HOSTS = []
REMOTE_RENDER_CONNECT_TIMEOUT = 1.0

 If you are running multiple carbon-caches on this machine (typically behind a relay using
 consistent hashing), you'll need to list the ip address, cache query port, and instance name of each carbon-cache
 instance on the local machine (NOT every carbon-cache in the entire cluster). The default cache query port is 7002
 and a common scheme is to use 7102 for instance b, 7202 for instance c, etc.

 You *should* use 127.0.0.1 here in most cases
CARBONLINK_HOSTS = ["127.0.0.1:7002:a"]
#}

CARBONLINK_HOSTS = [
{%- for instance in range(instances_count) -%}
"127.0.0.1:70{{ loop.index }}2:{{ instance }}"{% if not loop.last %}, {% endif %} {%- endfor -%}]
CARBONLINK_TIMEOUT = 1.0

{#-
 Additional Django Settings #
 Uncomment the following line for direct access to Django settings such as
 MIDDLEWARE_CLASSES or APPS
#}
from graphite.app_settings import *

MIDDLEWARE_CLASSES = MIDDLEWARE_CLASSES + (
    'django_statsd.middleware.GraphiteRequestTimingMiddleware',
    'django_statsd.middleware.GraphiteMiddleware'
)

SECRET_KEY = "{{ salt['password.pillar']('graphite:django_key', False) }}"
STATSD_PREFIX = 'graphite'
STATSD_CLIENT = 'django_statsd.clients.normal'
INSTALLED_APPS = list(INSTALLED_APPS)
INSTALLED_APPS.extend(['django_insecure'])

ALLOWED_HOSTS = ["{% for hostname in salt['pillar.get']('graphite:hostnames') %}{{ hostname }}{% if not loop.last %}", "{% endif %}{% endfor %}"]
