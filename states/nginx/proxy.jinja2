# {{ pillar['message_do_not_modify'] }}
{#
 A generic purpose HTTP/HTTPS proxy template.
 It's not currently used by Nginx state, but it can be used by other state.

 Arguments:

 - cache_size: Size of cache on disk.
   Default: No cache
   Check here http://nginx.org/en/docs/syntax.html for size format.
 - aggressive_cache: Turn on some settings to be sure content is cached on disk.
   Default: Not used
 - hostnames: list of hostname bind to this virtual host
   Default: No default it's REQUIRED.
 - allowed: list of allowed hosts/network in CIDR format:
            http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing
   Default: empty list, so nothing is blocked.
   If allowed list is empty and destination is forward proxy, only 127.0.0.1/32
    is allowed.
 - destination: Upstream peer.
   Default: act as a forward proxy (like default Squid behaviour).
   Value should be http://1.2.3.4 or http://5.6.7.8:1011 format.
   If this is not defined and it's a forward proxy, the allowed argument must be
   set for obvious security reasons. Unless that, only 127.0.0.1/32 is allowed.
 - http_port: which port the server listen on.
   Default: 80
 - ssl: SSL key pair name. See ssl state for more details.
   Default: None
 - https_port: which port the HTTPS server listen on.
   Default: 443
   This is ignored if ssl argument is not used.
 - dns_server: a single IP of a DNS server.
   Default: Google DNS server.
#}

{# cache directory is dynamically created from hostnames, http port and https
   ports arguments #}
{% if cache_size|default(False) %}
proxy_cache_path /var/cache/nginx/{{ hostnames[0] }}_{{ http_port|default(80) }}_{{ ssl|default('') }} levels=2:2:2 keys_zone=cache_{{ hostnames[0] }}_{{ http_port|default(80) }}_{{ ssl|default('') }}:1M inactive=1y max_size={{ cache_size }};
{% endif %}

server {
{% if http_port|default(80) %}
    listen {{ http_port|default(80) }};
{% endif %}
{% if ssl|default(False) %}
    listen {{ https_port|default(443) }} ssl;
    ssl_certificate /etc/ssl/{{ ssl }}/chained_ca.crt;
    ssl_certificate_key /etc/ssl/{{ ssl }}/server.pem;
    ssl_client_certificate /etc/ssl/{{ ssl }}/ca.crt;
    ssl_ciphers RC4:HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
{% endif %}

    server_name {% for hostname in hostnames %}{{ hostname }}{% if not loop.last %} {% endif %}{% endfor %};

    location / {
{% if cache_size|default(False) %}
        {# default: Google DNS #}
        resolver {{ dns_server|default('8.8.8.8') }};
        resolver_timeout 5s;
        proxy_cache cache_{{ hostnames[0] }}_{{ http_port|default(80) }}_{{ ssl|default('') }};
        proxy_temp_file_write_size {{ cache_size }};
    {% if aggressive_cache|default(False) %}
        proxy_cache_use_stale error timeout invalid_header updating http_500 http_502 http_503 http_504 http_404;
        {# proxy_cache_valid 200 302 1d; #}
        proxy_cookie_domain off;
        proxy_cookie_path off;
        proxy_http_version 1.1;
        proxy_ignore_client_abort on;
        proxy_ignore_headers X-Accel-Redirect X-Accel-Expires X-Accel-Limit-Rate X-Accel-Buffering X-Accel-Charset Expires Cache-Control Set-Cookie;
        proxy_pass_request_headers off;
    {% endif %}
{% endif %}
        proxy_pass {{ destination|default('$scheme://$http_host$uri$is_args$args') }};
        proxy_set_header X-Real-IP $remote_addr;
{% for source in allowed|default([]) -%}
        allow {{ source }};
    {% if loop.last %}
        deny all;
    {% endif %}
{% else -%}
    {#
     If there is now allowed network/hosts and this is a forward proxy
     #}
    {%- if not destination|default(False) %}
        allow 127.0.0.1/32;
        deny all;
    {% endif -%}
{%- endfor %}
    }
}
